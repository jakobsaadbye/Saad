import "c_stdlib";
import "c_string";
import "arrays";

StringBuilder :: struct {
    buffer:    *u8;
    cursor:    int;
    capacity:  int;
}

NewStringBuilder :: (initialCapacity: int) -> StringBuilder {
    buffer: *u8 = malloc(initialCapacity);

    memset(buffer, 0, initialCapacity);

    return {
        buffer   = buffer,
        cursor   = 0,
        capacity = initialCapacity,
    };
}

internalGrow :: method (sb: *StringBuilder, len: int) {
    newCapacity := sb.capacity * 2;
    while newCapacity <= sb.cursor + len {
        newCapacity *= 2;
    }

    newBuffer: *u8 = realloc(sb.buffer, newCapacity);
    if newBuffer == null {
        print("OutOfMemoryException: Failed to reallocate a new buffer for the string builder");
        exit(1);
    }

    sb.buffer = newBuffer;
    sb.capacity = newCapacity;

    memset(&sb.buffer[sb.cursor], 0, newCapacity - sb.cursor);
}

internalAdd :: method (sb: *StringBuilder, strPtr: *u8, len: int) {
    if sb.cursor + len < sb.capacity {
        memcpy(&sb.buffer[sb.cursor], strPtr, len);
        sb.cursor += len;
    } else {
        sb.internalGrow(len);
    
        // Append the string
        memcpy(&sb.buffer[sb.cursor], strPtr, len);
        sb.cursor += len;
    }
}

addStringSlice :: method (sb: *StringBuilder, str: string, start: int, end: int) {
    strLen := end - start;
    strPtr := cast(*u8)str;
    strPtr = &strPtr[start];
    sb.internalAdd(strPtr, strLen);
}

addChar :: method (sb: *StringBuilder, char: u8) {
    strLen := 1;
    strPtr := &char;
    sb.internalAdd(strPtr, strLen);
}

addString :: method (sb: *StringBuilder, str: string) {
    strLen := strlen(str);
    strPtr := cast(*u8)str;
    sb.internalAdd(strPtr, strLen);
}

addInt :: method (sb: *StringBuilder, v: int) {
    if v == 0 {
        sb.addChar(48);
        return;
    }

    tmp: [32]u8; // enough for 64-bit int

    n := 0;
    while v != 0 {
        digit := v % 10;
        v = v / 10;

        char := cast(u8) (digit + 48);

        tmp[n] = char;
        n += 1;
    }

    // Add the digits in reverse order
    for i in 0..n {
        ri := (n - 1) - i;
        char := tmp[ri];
        sb.addChar(char);
    }
}

addFloat32 :: method (sb: *StringBuilder, v: f32) {
    buf: [18]u8;
    sprintf(buf.data, "%f", v);

    strPtr := cast(*u8) buf.data;
    strLen := strlen(cast(string) strPtr);
    sb.internalAdd(strPtr, strLen);
}

addFloat64 :: method (sb: *StringBuilder, v: f64) {
    buf: [18]u8;
    sprintf(buf.data, "%lf", v);

    strPtr := cast(*u8) buf.data;
    strLen := strlen(cast(string) strPtr);
    sb.internalAdd(strPtr, strLen);
}

addAnyValue :: method (sb: *StringBuilder, arg: any)  {
    if arg.type.kind == .Int {
        value := cast(*int) arg.data;
        sb.addInt(*value);
    }
    else if arg.type.kind == .Float {
        if (arg.type.size == 4) {
            value := cast(*f32) arg.data;
            sb.addFloat32(*value);
        } else {
            value := cast(*f64) arg.data;
            sb.addFloat64(*value);
        }
    }
    else if arg.type.kind == .Bool {
        value := cast(*bool) arg.data;
        if *value {
            sb.addString("true");
        } else {
            sb.addString("false");
        }
    }
    else if arg.type.kind == .String {
        value := cast(*string) arg.data;
        sb.addString(*value);
    }
    else if arg.type.kind == .Enum {
        enumType := cast(*TypeEnum) arg.type;
        sb.addString(enumType.head.name);
        sb.addString(".");
        sb.addString(enumType.valueName);
    }
    else if arg.type.kind == .Pointer {
        ptrType := cast(*TypePointer) arg.type;

        buf: [64]u8;
        sprintf(buf.data, "0x%p", *arg.data);

        sb.addString(cast(string)buf.data);
    }
    else if arg.type.kind == .Array {
        arrType := cast(*TypeArray) arg.type;

        sb.addString("[");
        for i in 0..arrType.count {
            
            elemSize := arrType.elemType.size;

            elemPtr: *u8 = null;
            if arrType.kind == .Fixed {
                arrPtr := cast(**u8) arg.data;
                elem0Ptr := *arrPtr;
                elemPtr = &elem0Ptr[i * elemSize];
            } else if arrType.kind == .Slice {
                slicePtr := cast(*[]u8) arg.data;
                slice := *slicePtr;
                elem0 := slice.data;
                elemPtr = &elem0[i * elemSize];
            } else if arrType.kind == .Dynamic {
                dynArrPtr := cast(*[..]u8) arg.data;
                dynArr := *dynArrPtr;
                elem0 := dynArr.data;
                elemPtr = &elem0[i * elemSize];
            }

            // Only show the full value if its a primitive type since we don't
            // generate type descriptors for each element.
            if arrType.elemType.isPrimitive() {
                value: any;
                value.type = arrType.elemType;
                value.data = elemPtr;
                sb.addAnyValue(value);
            } 
            else {
                buf: [64]u8;
                sprintf(buf.data, "0x%p", elemPtr);
                sb.addString(cast(string)buf.data);
            }

            if i != arrType.count - 1 {
                sb.addString(", ");
            }
        }
        sb.addString("]");
    }
    else if arg.type.kind == .Struct {
        structType := cast(*TypeStruct) arg.type;
        sb.addString(structType.head.name);
        sb.addString("{ ");
        for member, i in structType.members {
            sb.addString(member.name);
            sb.addString(" = ");

            value: any;
            value.type = member.type;
            value.data = member.value;
            sb.addAnyValue(value);

            if i != structType.members.count - 1 {
                sb.addString(", ");
            }
        }
        sb.addString(" }");
    }
    else {
        sb.addString("<");
        sb.addString(arg.type.name);
        sb.addString(">");
    }
}

add :: method (sb: *StringBuilder, format: string, args: ...any) {

    // Scan the format string to find all the placeholders
    placeholderIndicies: [..]int;
    for i in 0..strlen(format) {
        c := (cast(*u8)format)[i];
        if c == 37 { // '%'
            appendInt(&placeholderIndicies, i);
        }
    }

    // Build up the result string by pasting each segment of the source string
    cursor := 0;
    for index, i in placeholderIndicies {

        // Add the static text up untill the placeholder
        sb.addStringSlice(format, cursor, index);

        // Fill in the placeholder
        arg := args[i];
        sb.addAnyValue(arg);

        cursor = index + 1;
    }

    // Append the trailing part after the last placeholder
    sb.addStringSlice(format, cursor, strlen(format));
}

clear :: method (sb: *StringBuilder) {
    memset(sb.buffer, 0, sb.capacity);
}

toString :: method (sb: *StringBuilder) -> string {
    return cast(string) sb.buffer;
}

free :: method (sb: *StringBuilder) {
    free(sb.buffer);
}