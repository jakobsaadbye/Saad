import "io";
import "math";
import "raylib";
import "faker";

BALL_SIZE :: 20;
BRICK_WIDTH  :: 100;
BRICK_HEIGHT :: 30;
BRICK_PADDING :: 12;
BRICK_ROWS :: 8;
BRICK_COLS :: 8;
PICKUP_SPAWN_CHANCE :: 25; // in percentage
PICKUP_SIZE :: 26;

INITIAL_BAR_WIDTH     :: 100;
INITIAL_BALL_VELOCITY :: 400.0;

TOP_MARGIN :: 80;
WINDOW_WIDTH :: 1200;
WINDOW_HEIGHT :: 800;


Brick :: struct {
    x:     int;
    y:     int;
    color: Color;
    dead:  bool;
}

Bar :: struct {
    x:      float;
    y:      float;
    width:  float;
    height: float;
    velX:   float;
}

Ball :: struct {
    x:     float;
    y:     float;
    size:  float;
    velX:  float;
    velY:  float;
}

Player :: struct {
    score: int;
    bricksDestroyed: int;
    lives: int;
    isHoldingBall: bool;
    hasFireballPowerup: bool;
    fireballPowerupDuration: int;
}

PickupType :: enum {
    BallSpeedUp,
    BallSlowDown,
    BarWiden,
    BarShorten,
    Fireball,
    COUNT,
}

Pickup :: struct {
    type: PickupType;
    x: float;
    y: float;
    velY: float;
    isShown: bool;
}

PickupSpawner :: struct {
    pickups: []Pickup;
    freeIndex: int;
}

Particle :: struct {
    pos: Vector2;
    vel: Vector2;
    color: Color;
    size: int;
    lifetime: int;
}

ParticleEmitter :: struct {
    particles: [25]Particle;
    pos: Vector2;
    vel: Vector2;
    radius: float;
    color: Color;
    particleLifetime: int;
    isActive: bool;
}

GameState :: struct {
    player:    *Player;
    ball:      *Ball;
    bar:       *Bar;
    sounds:   []Sound;
    textures: []Texture;
    particleEmitters: []ParticleEmitter;
    liveEmitterCount: int;
    pickupSpawner:   *PickupSpawner;
}

getRect :: method (brick: Brick) -> Rectangle {
    return {
        xx brick.x,
        xx brick.y,
        BRICK_WIDTH,
        BRICK_HEIGHT,
    };
}

getRect :: method (ball: Ball) -> Rectangle {
    return {
        ball.x,
        ball.y,
        ball.size,
        ball.size,
    };
}

getRect :: method (bar: Bar) -> Rectangle {
    return {
        bar.x,
        bar.y,
        bar.width,
        bar.height,
    };
}

beginEmit :: method (pe: *ParticleEmitter) {
    for *p in pe.particles {
        p.pos.x = xx GetRandomValue(xx (pe.pos.x - pe.radius), xx (pe.pos.x + pe.radius));
        p.pos.y = xx GetRandomValue(xx (pe.pos.y - pe.radius), xx (pe.pos.y + pe.radius));
        
        spread := 200.0;
        velX: int = GetRandomValue(xx (pe.vel.x - spread), xx (pe.vel.x + spread));
        velY: int = GetRandomValue(xx (pe.vel.y - spread), xx (pe.vel.y + spread));

        p.vel.x = xx velX;
        p.vel.y = xx velY;

        p.size = GetRandomValue(6, 8);
        p.color = pe.color;
        p.lifetime = pe.particleLifetime;
    }
    pe.isActive = true;
}

update :: method (pe: *ParticleEmitter) {
    if !pe.isActive {
        return;
    }

    dt := GetFrameTime();

    for *p in pe.particles {
        p.pos.x += p.vel.x * dt;
        p.pos.y += p.vel.y * dt;

        p.lifetime -= cast(int) (dt * 1000.0);
        if p.lifetime < 0 {
            p.lifetime = 0;
        }

        p.color.a = cast(u8) (255.0 *  p.lifetime / pe.particleLifetime);
    }
}

draw :: method (pe: *ParticleEmitter) {
    if !pe.isActive {
        return;
    }

    for *p in pe.particles {
        if p.lifetime > 0 {
            DrawRectangle(xx p.pos.x, xx p.pos.y, p.size, p.size, p.color);
        }
    }
}

main :: () {
    COLOR_WHITE := Color{255, 255, 255, 255};

    InitWindow(WINDOW_WIDTH, WINDOW_HEIGHT, "Super Breakout");
    InitAudioDevice();
    SetTargetFPS(90);

    //
    // Textxures
    //
    heartTexture := LoadTexture("data/textures/heart.png");
    heartTexture.width  = 24;
    heartTexture.height = 24;


    pickupTextures : [PickupType.COUNT]Texture = [
        LoadTexture("data/textures/pickups/ball_speed_up.png"),
        LoadTexture("data/textures/pickups/ball_slow_down.png"),
        LoadTexture("data/textures/pickups/bar_widen.png"),
        LoadTexture("data/textures/pickups/bar_shorten.png"),
        LoadTexture("data/textures/pickups/fire_ball.png"),
    ];

    // Scale each pickup texture
    for 0..pickupTextures.count {
        texture := &pickupTextures[it];
        texture.width  = PICKUP_SIZE;
        texture.height = PICKUP_SIZE;
    }


    //
    // Sounds
    //
    soundBallBounce1   := LoadSound("data/sounds/ball_bounce_1.mp3");
    soundBallBounce2   := LoadSound("data/sounds/ball_bounce_2.wav");
    soundPickup        := LoadSound("data/sounds/pickup.wav");
    soundGameOver      := LoadSound("data/sounds/game_over.wav");
    soundLostLife      := LoadSound("data/sounds/lost_life.wav");
    soundLevelComplete := LoadSound("data/sounds/level_complete.mp3");

    //
    // Game state + variables
    //
    player := Player{
        score = 0,
        bricksDestroyed = 0,
        lives = 3,
        isHoldingBall = true,
    };

    ball := Ball{
        x = 4,
        y = 4,
        size = BALL_SIZE,
        velX = INITIAL_BALL_VELOCITY,
        velY = INITIAL_BALL_VELOCITY,
    };

    bar := Bar{
        x = WINDOW_WIDTH * 0.5 - INITIAL_BAR_WIDTH * 0.5,
        y = WINDOW_HEIGHT - 70,
        width = INITIAL_BAR_WIDTH,
        height = 15,
        velX = 0,
    };

    pickups: [16]Pickup;
    pickupSpawner := PickupSpawner{pickups = pickups};

    particleEmitters: [4]ParticleEmitter;

    game := GameState{
        player = &player,
        ball   = &ball,
        bar    = &bar,
        sounds = [
            soundBallBounce1,
            soundBallBounce2,
            soundPickup,
            soundGameOver,
            soundLostLife,
            soundLevelComplete,
        ],
        textures         = pickupTextures,
        particleEmitters = particleEmitters,
        pickupSpawner    = &pickupSpawner
    };

    deadZone := Rectangle{0, WINDOW_HEIGHT - (WINDOW_HEIGHT - (bar.y + bar.height)), WINDOW_WIDTH, (WINDOW_HEIGHT - (bar.y + bar.height))};

    scoreText: [16]u8;

    brickColors: [BRICK_ROWS]Color = [
        {255,  55, 140, 255}, // vibrant pink/magenta
        {255,  45,  45, 255}, // bright red
        {255, 120,  20, 255}, // neon orange
        {255, 210,   0, 255}, // vivid yellow-gold
        { 40, 200,  40, 255}, // electric green
        { 45,  70, 255, 255}, // strong blue
        {160,  60, 255, 255}, // bright purple
        {  0, 255, 220, 255 }, // bright aqua / teal-cyan
    ];

    // Initiate the bricks
    bricks: [BRICK_ROWS * BRICK_COLS] Brick;

    brick_row_width := (BRICK_WIDTH + BRICK_PADDING) * BRICK_COLS - 1;

    for row in 0..BRICK_ROWS {
        for col in 0..BRICK_COLS {
            index := row * BRICK_COLS + col;
            
            x := (BRICK_WIDTH + BRICK_PADDING)  * col + (WINDOW_WIDTH / 2) - (brick_row_width / 2);
            y := (BRICK_HEIGHT + BRICK_PADDING) * row + TOP_MARGIN;

            color := brickColors[row];

            brick := Brick{
                x = x,
                y = y,
                color = color,
                dead = false,
            };

            bricks[index] = brick;
        }
    }

    // Math for bouncing the ball with the bar at a certain angle
    ANGLE_MIN := degreeToRadians(15.0);
    ANGLE_MAX := degreeToRadians(165.0);

    //
    // Main game-loop
    //
    while !WindowShouldClose() {

        dt := GetFrameTime();

        //
        // Input
        //
        mousePos := GetMousePosition();

        // Move the bar in the direction of the mouse cursor
        distanceForMaxVelocity := 100.0;
        maxVelocity            := 1000.0;

        distanceBarMouse := mousePos.x - (bar.x + bar.width*0.5);

        if distanceBarMouse >= distanceForMaxVelocity {
            bar.velX = maxVelocity;
        } 
        else if distanceBarMouse <= -distanceForMaxVelocity {
            bar.velX = -maxVelocity;
        } 
        else {
            // Interpolate the velocity
            direction := 1;
            if distanceBarMouse < 0 {
                distanceBarMouse *= -1;
                direction = -1;
            }

            t := distanceBarMouse / distanceForMaxVelocity;

            speed := lerp(0, maxVelocity, t);

            bar.velX = speed * direction;
        }

        bar.x += bar.velX * dt;

        if bar.x < 0 {
            bar.x = 0;
        }
        if bar.x > WINDOW_WIDTH - bar.width {
            bar.x = xx WINDOW_WIDTH - bar.width;
        }

        if IsMouseButtonPressed(.LEFT) {
            player.isHoldingBall = false;
        }

        //
        // Hit detection
        //

        // Simulate the next ball position
        nextBall  := ball;
        nextBall.x = ball.x + ball.velX * dt;
        nextBall.y = ball.y + ball.velY * dt;
        
        // Collisions ball and walls
        if nextBall.x < 0 || nextBall.x + nextBall.size > WINDOW_WIDTH {
            ball.velX = -ball.velX;
            PlaySound(soundBallBounce2);
        }

        if nextBall.y < 0 || nextBall.y + nextBall.size > WINDOW_HEIGHT {
            ball.velY = -ball.velY;
            PlaySound(soundBallBounce2);
        }

        // Collision ball and bar
        nextBallRect := nextBall.getRect();
        barRect      := bar.getRect();

        if !player.isHoldingBall && CheckCollisionRecs(nextBallRect, barRect) {

            // The outbound angle of the ball when hitting the bar, follows that of a half circle.
            // If the ball hits the far left of the bar, the out angle is 20 degree
            // If the ball hits the far right of the bar, the out angle is 160 degree
            // Everything in between, we lerp between those two angles, hence, if the ball hits
            // the middle of the bar, the ball will go straight up in a 90 degree angle
            dx := nextBallRect.x + nextBallRect.width * 0.5 - barRect.x;

            t := dx / barRect.width;

            // Clamp t
            if t < 0 { t = 0; }
            if t > 1.0 { t = 1.0; }

            theta := lerp(ANGLE_MIN, ANGLE_MAX, t);

            directionVector := Vector2{
                x = - xx cos(xx theta),
                y = - xx sin(xx theta),
            };

            speed := cast(f32) sqrt(xx (ball.velX*ball.velX + ball.velY*ball.velY));

            ball.velX = directionVector.x * speed;
            ball.velY = directionVector.y * speed;

            PlaySound(soundBallBounce2);
        }

        // Collision ball and bricks
        nextBallRect = nextBall.getRect();

        for row in 0..BRICK_ROWS {
            for col in 0..BRICK_COLS {
                index := row * BRICK_COLS + col;
                brick := &bricks[index];

                if brick.dead { continue; } // mehhhh

                rect := brick.getRect();
                if CheckCollisionRecs(nextBallRect, rect) {
                    handleBrickCollision(&game, brick);
                    break;
                }
            }
        }

        // Collision bar and pickups
        {
            barRect := bar.getRect();

            for i in 0..pickups.count {
                pickup := &pickups[i];
                if !pickup.isShown { continue; }

                pickupRect := Rectangle{pickup.x, pickup.y, PICKUP_SIZE, PICKUP_SIZE};

                if CheckCollisionRecs(barRect, pickupRect) {
                    handleOnPickup(pickup, &bar, &ball, &player, soundPickup);
                }
            }
        }
        

        // Collision ball and dead zone
        ballRect := ball.getRect();
        if CheckCollisionRecs(ballRect, deadZone) {
            player.isHoldingBall = true;
            player.lives -= 1;

            if player.lives <= 0 {
                PlaySound(soundGameOver);
                print("You completely lost!");
            } else {
                PlaySound(soundLostLife);

                // Reset and remove all powerup effects
                player.hasFireballPowerup = false;
                bar.width = INITIAL_BAR_WIDTH;
                ball.velX = INITIAL_BALL_VELOCITY;
                ball.velY = INITIAL_BALL_VELOCITY;
            }
        }

        // Ball updates
        if player.isHoldingBall {
            ball.x = bar.x + bar.width * 0.5 - BALL_SIZE * 0.5;
            ball.y = bar.y - BALL_SIZE - 4;
        } else {
            // Follow normal ball behaviour
            ball.x += ball.velX * dt;
            ball.y += ball.velY * dt;
        }

        updatePlayerEffects(&player);
        updatePickupPositions(pickups);

        for _, i in game.particleEmitters {
            pe := &game.particleEmitters[i];
            pe.update();
        }

        // Check for winning condition
        if player.bricksDestroyed == bricks.count {
            print("You won!");
            player.bricksDestroyed = 0;
        }

        //
        // Drawing
        //
        BeginDrawing();
        ClearBackground({ 30, 30, 30, 30 });

        for _, i in game.particleEmitters {
            pe := &game.particleEmitters[i];
            pe.draw();
        }

        // Draw pickups
        for i in 0..pickups.count {
            pickup := &pickups[i];

            if !(pickup.isShown) { 
                continue; 
            }

            texture := pickupTextures[pickup.type];

            DrawRectangle(xx pickup.x, xx pickup.y, texture.width, texture.height, Color{50, 50, 50, 255});
            DrawTexture(texture, xx pickup.x, xx pickup.y, Color{255, 255, 255, 255});
        }
        
        // Draw bricks
        for b in bricks {
            if b.dead {
                continue;
            }

            BORDER_THICKNESS :: 3;
            borderColor := b.color; 
            borderColor.a = 170;

            borderRect := Rectangle{xx b.x, xx b.y, BRICK_WIDTH, BRICK_HEIGHT};

            DrawRectangle(b.x + BORDER_THICKNESS, b.y + BORDER_THICKNESS, BRICK_WIDTH - 2 * BORDER_THICKNESS, BRICK_HEIGHT - 2 * BORDER_THICKNESS, b.color);
            DrawRectangleLinesEx(borderRect, BORDER_THICKNESS, borderColor);
        }

        // Draw the ball
        {
            ballColor := COLOR_WHITE;
            if player.hasFireballPowerup {
                ballColor = {255, 20, 20, 255};
            }
            DrawRectangle(xx ball.x, xx ball.y, xx ball.size, xx ball.size, ballColor);
        }
        
        // Draw the bar
        DrawRectangle(xx bar.x, xx bar.y, xx bar.width, xx bar.height, COLOR_WHITE);

        // DrawFPS(WINDOW_WIDTH - 100, 16);

        // Draw lives
        for 0..player.lives {
            padX := 6.0;
            posX := cast(int) (10.0 + (heartTexture.width + padX) * it);

            DrawTexture(heartTexture, posX, 16, Color{255, 255, 255, 255});
        }

        // Draw score
        sprintf(scoreText.data, xx "Score: %d", player.score);
        DrawText(xx scoreText.data, 105, 16, 24, COLOR_WHITE);

        // Draw the dead zone        
        // DrawRectangleRec(deadZone, {255, 0, 0, 30});

        EndDrawing();
    }

    UnloadTexture(heartTexture);

    for pickupTextures {
        UnloadTexture(it);
    }

    CloseAudioDevice();
    CloseWindow();
}

handleBrickCollision :: (game: *GameState, brick: *Brick) {

    doBounce := true;
    if game.player.hasFireballPowerup {
        doBounce = false;
    }

    brick.dead = true;
    game.player.score += 100;
    game.player.bricksDestroyed += 1;

    PlaySound(game.sounds[0]); // soundBallBounce1

    // Play a particle effect
    pe := ParticleEmitter{
        pos    = {xx (brick.x + BRICK_WIDTH*0.5), xx (brick.y + BRICK_HEIGHT*0.5)},
        vel    = {game.ball.velX * 0.3, game.ball.velY * 0.3},
        radius = 16,
        color  = brick.color,
        particleLifetime = 500,
        isActive = false,
    };

    next := game.liveEmitterCount;
    game.particleEmitters[next] = pe;
    game.particleEmitters[next].beginEmit();

    game.liveEmitterCount += 1;
    if game.liveEmitterCount >= game.particleEmitters.count {
        game.liveEmitterCount = 0;
    }

    // Bounce the ball
    if doBounce {
        rect := brick.getRect();
        bounceBall(game.ball, rect);
    }

    r := GetRandomValue(0, 100);
    if r <= PICKUP_SPAWN_CHANCE {
        spawnPickup(game.pickupSpawner, {xx brick.x, xx brick.y});
    }
}

spawnPickup :: (ps: *PickupSpawner, pos: Vector2) {
    index := GetRandomValue(0, xx PickupType.COUNT - 1);

    pickup := Pickup{
        type = cast(PickupType) index,
        x = pos.x,
        y = pos.y,
        velY = xx GetRandomValue(80, 120),
        isShown = true,
    };
    
    ps.pickups[ps.freeIndex] = pickup;
    ps.freeIndex += 1;
}

handleOnPickup :: (pickup: *Pickup, bar: *Bar, ball: *Ball, player: *Player, pickup_sound: Sound) {
    pickup.isShown = false;

    if pickup.type == .BallSpeedUp {
        ball.velX *= 1 + 0.2;
        ball.velY *= 1 + 0.2;
    }
    else if pickup.type == .BallSlowDown {
        ball.velX *= 1 - 0.2;
        ball.velY *= 1 - 0.2;
    }
    else if pickup.type == .BarWiden {
        bar.width += 20;
    }
    else if pickup.type == .BarShorten {
        bar.width -= 20;
    }
    else if pickup.type == .Fireball {
        player.hasFireballPowerup      = true;
        player.fireballPowerupDuration = 1500;
    }

    PlaySound(pickup_sound);
}

updatePickupPositions :: (pickups: []Pickup) {
    dt := GetFrameTime();

    for i in 0..pickups.count {
        p := &pickups[i];

        if p.isShown {
            p.y += p.velY * dt;
        }

        if p.y > WINDOW_HEIGHT {
            p.isShown = false;
        }
    }
}

updatePlayerEffects :: (player: *Player) {
    dtMilliseconds := GetFrameTime() * 1000;

    if player.hasFireballPowerup {
        
        player.fireballPowerupDuration -= xx dtMilliseconds;

        if player.fireballPowerupDuration <= 0 {
            player.hasFireballPowerup = false;
        }
    }
}

bounceBall :: (ball: *Ball, b: Rectangle) {
    overlap := Vector2{};
    a       := ball.getRect();

    // Figure out how much we overlap with the rectangle
    if ball.velX > 0 {
        overlap.x = a.x + a.width - b.x; 
    } else {
        overlap.x = b.x + b.width - a.x; 
    }

    if ball.velY > 0 {
        overlap.y = a.y + a.height - b.y; 
    } else {
        overlap.y = b.y + b.height - a.y; 
    }

    // Adjust direction and position of the ball to make it unstuck
    if overlap.x < overlap.y {
        ball.velX = -ball.velX;
        ball.x    += overlap.x;
    } else {
        ball.velY = -ball.velY;
        ball.y    += overlap.y;
    }
}

degreeToRadians :: (deg: f32) -> f32 {
    return deg * (PI / 180.0);
}

lerp :: (a: f32, b: f32, t: f32) -> f32 {
    return a + (b - a) * t;
}